var Set=function(t){this.collection=[],this.type="SET",this.size=0,t instanceof Array?this.collection=t.slice():"Function"==typeof t&&"SET"===t.type&&(this.collection=t.values().slice()),this.has=function(t){return-1!==this.collection.indexOf(t)},this.values=(()=>this.collection),this.add=function(t){this.has(t)||(this.collection.push(t),this.size++)},this.append=function(t){t.forEach(t=>{this.has(t)||(this.collection.push(t),this.size++)})},this.remove=function(t){"Object"!=typeof t&&"Function"!=typeof t&&this.has(t)?(this.collection.splice(this.collection.indexOf(t),1),this.size--):t instanceof Array?this.reduce(t):t instanceof Function&&"SET"===t.type&&this.reduce(t.values())},this.reduce=function(t){if(!(t instanceof Array))throw new TypeError("TypeError: Set.reduce only accepts an Array as parameter");t.forEach(t=>{this.has(t)&&(this.collection.splice(this.collection.indexOf(t),1),this.size--)})},this.union=function(t){var e=new Set;return e.append(this.collection),t.values().forEach(t=>{e.add(t)}),e},this.intersection=function(t){let e=new Set;return t.values().forEach(t=>{this.has(t)&&e.add(t)}),e},this.difference=function(t){let e=new Set;return this.values().forEach(i=>{t.has(i)||e.add(i)}),e}};export default Set;